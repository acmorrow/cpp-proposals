<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
  <head>
    <title>[DRAFT] A proposal to add swappability traits to the standard library</title>
    <meta http-equiv=Content-Type content="text/html; charset=windows-1252">
  </head>

  <body>
    <font size=-1>
      Date: 2013-01-27 <br>
      Project: Programming Language C++, Library Working Group <br>
      Reply-To: Andrew Morrow &lt;andrew.c.morrow@gmail.com&gt; <br>
      Document number: TBD <br>
    </font>

    <h1>[DRAFT] A proposal to add swappability traits to the standard library</h1>

    <h2>I. Table of Contents</h2>
    <ol type="I" start=2>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#motivation">Motivation and Scope</a></li>
      <li><a href="#impact">Impact on the Standard</a></li>
      <li><a href="#design">Design Decisions</a></li>
      <li><a href="#spec">Technical Specification [INCOMPLETE]</a></li>
      <li><a href="#impl">Implementation</a></li>
      <li><a href="#thanks">Acknowledgements</a></li>
      <li><a href="#biblio">References</a></li>
    </ol>

    <a name="introduction"><h2>II. Introduction</h2></a>
    <p>
      This proposal proposes the addition of two new type relationship properties to the C++
      standard library: <tt>std::is_swappable&lt;T, U&gt;</tt>
      and <tt>std::is_nothrow_swappable&lt;T, U&gt;</tt>. The former will derive
      from <tt>std::true_type</tt> if the expression '<tt>swap(declval&lt;T&&gt;(),
      declval&lt;U&&gt;())</tt>' resolves when
      <tt>std::swap</tt> is in scope, and from <tt>std::false_type</tt> otherwise. The latter
      will derive from <tt>std::true_type</tt> if the same expression resolves
      when <tt>std::swap</tt> is in scope and the resolved function is known to be
      non-throwing, or <tt>std::false_type</tt> otherwise.
    </p>

    <a name="motivation"><h2>III. Motivation and Scope</h2></a>
    <p>
      When writing a template it is often important to know whether or not values of a
      particular template type parameter are swappable, either via <tt>std::swap</tt> or by a
      swap overload found by argument dependent lookup ("ADL swap"). This information could be
      used in combination with <tt>std::enable_if</tt>, for instance, to inhibit generation of
      a swap overload for the template for the case where values for a particular type
      parameter are not swappable. It is also often important to know whether a call to 'swap'
      may throw, primarily to propagate noexcept. In particular, the noexcept status of a swap
      call is of interest when implementing a copy assignment operator or move assignment
      operator in terms of swap to achieve the strong exception safety guarantee.
    </p>

    <p>
      The current set of type relationship traits defined by the standard does not include
      traits to determine whether a swap is available for any two types, or, if it is, whether
      or not the resolved swap is non-throwing. Without these traits, it is left to library
      authors to use the existing library and language features to make the
      determination. However, the 'obvious' solutions are often wrong:

      For example, in the case of attempting to determine the noexcept status of a function
      that calls 'swap', it is not possible to form a correct noexcept specifier directly:
    </p>

    <p>
      We can't use std::swap inside the noexcept operator if we are using ADL swap in the body:

      <blockquote><tt><pre>
template&lt;typename T&gt;
struct X {
    // The swap in the noexcept expression may not be the same swap as found by ADL below.
    friend void swap(X&amp; a, X&amp; b) noexcept(noexcept(std::swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;()))) {
        using std::swap;
        swap(a.val, b.val);
    }
    T val;
};
      </pre></tt></blockquote>

      But we can't use a non-qualified swap in the noexcept operator either:

      <blockquote><tt><pre>
template&lt;typename T&gt;
struct X {
    // ERROR if std::swap is not in scope and there is no swap found by ADL for T.
    friend void swap(X&amp; a, X&amp; b) noexcept(noexcept(swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;()))) {
        using std::swap;
        swap(a.val, b.val);
    }
    T val;
};
      </pre></tt></blockquote>

      And we can't enable ADL swap inside the noexcept operator:

      <blockquote><tt><pre>
template&lt;typename T&gt;
struct X {
    // ERROR: Cannot have a statement inside a noexcept operator; it requires an expression.
    friend void swap(X&amp; a, X&amp; b) noexcept(noexcept(using std::swap; swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;()))) {
        using std::swap;
        swap(a.val, b.val);
    }
    T val;
};
      </pre></tt></blockquote>
    </p>

    <p>
      While it is not particularly difficult to build workarounds for this
      issue <a href="#biblio.so-adl-noexcept">[1]</a><a href="#biblio.github-acm-swap-traits">[2]</a>
      (and in particular see libc++<a href="#biblio.libcxx-swap-trats">[3]</a> which defines and
      makes extensive use of these traits within its implementation, but of course does not
      expose them), it seems reasonable that a future version of the standard library should
      provide this facility. This is especially true given the fundamental importance of swap
      (and of non-throwing swap in particular) to properly implementing move operations.
    </p>

    <a name="impact"><h2>IV. Impact On the Standard</h2></a>
    <p>
      This proposal is a library extension. It does not require changes to any standard
      classes, functions or headers. It can be implemented in C++11 and requires no core
      language changes.
    </p>

    <a name="design"><h2>V. Design Decisions</h2></a>
    <h3>Proposed Design</h3>
    <h4>Goals</h4>
    <p>
      The behavior of the proposed classes is designed to be as similar possible to the
      existing type relationship classes defined in the <tt>&lt;type_traits&gt;</tt> header and
      to meet the requirements of [20.9.6] for templates that may be used to query
      relationships between types at compile time. Specifically, the classes meet the
      requirements for a <tt>BinaryTypeTrait</tt> as described in [20.9.1]. The names of the
      proposed classes are selected to be as similar as possible to the names of the existing
      type property and type relationship classes as described in [20.9.2].
    </p>

    <h4>Constructors</h4>
    <p>
      The proposed classes declare no constructors of their own and do not manipulate the
      visibility of constructors from their base classes. Since the base classes are
      either <tt>std::true_type</tt> or <tt>std::false_type</tt>, the proposed classes will meet
      the requirement that they be <tt>DefaultConstructible</tt> and <tt>CopyConstructible</tt>.
    </p>

    <h4>Public Data</h4>
    <p>
      By [20.9.1], as an implementation of <tt>BinaryTypeTrait</tt>, the classes must derive
      publicly from a specialization of <tt>std::integral_constant</tt>, and, by [20.9.6], that
      specialization must be by way of deriving from <tt>std::true_type</tt>
      or <tt>std::false_type</tt>. The classes do not define any other members or manipulate
      the visibility of members from their base classes.
    <p>

    <h3>Alternative Designs</h3>
    <p>
      One potential way out of the difficulty of obtaining the right swap in
      the <tt>noexcept</tt> oeprator would be if the language provided a "using expression"
      rather than a "using statement", in which case the third example above could be made to
      work:

      <blockquote><tt><pre>
template&lt;typename T&gt;
struct X {
    // OK?: Some sort of way to have an expression that 'uses' something.
    friend void swap(X&amp; a, X&amp; b) noexcept(noexcept(with using std::swap swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;()))) {
        using std::swap;
        swap(a.val, b.val);
    }
    T val;
};
      </pre></tt></blockquote>

      One advantage of having such a 'using expression' available in the language is that it
      solves the more general problem of obtaining names via 'std or ADL' inside a noexcept
      operator. However, this would be a much more significant change, involving updates to the
      core language rather than just the standard library, and it is not clear how often such a
      feature would be needed for things other than swap.
    </p>

    <a name="spec"><h2>VI. Technical Specifications [INCOMPLETE]</h2></a>
    <h3>Header</h3>
    The new classes will be added to a new header <tt>swap_traits</tt>.
    <h4> 20.9.X Header <tt>swap_traits</tt> synopsis</h4>
              <blockquote><tt><pre>
namespace std {
  template&lt;typename T, typename U = T&gt;
  struct is_swappable;

  template&lt;typename T, typename U = T&gt;
  struct is_nothrow_swappable;
}
              </pre></tt></blockquote>

    <h3>20.9.6 Relationships between types [meta.rel]</h3>

    <p>
      Add two new rows to Table 51:
      <center>
        <table border>
          <caption>Table 51 - Type relationship predicates</caption>
          <tr><td>Template</td><td>Condition</td><td>Comments</td></tr>
          <tr>
            <td>
              <blockquote><tt><pre>
template&lt;typename T, typename U = T&gt;
struct is_swappable;
              </pre></tt></blockquote>
            </td>
            <td>
              The expression <tt>swap(declval&lt;T&&gt;(), declval&lt;U&&gt;())</tt> resolves.
            </td>
            <td>
              The set of swaps considered for resolution must include <tt>std::swap</tt> as
              well as swap overloads available via argument dependent lookup.
            </td>
          </tr>
          <tr>
            <td>
              <blockquote><tt><pre>
template&lt;typename T, typename U = T&gt;
struct is_nothrow_swappable;
              </pre></tt></blockquote>
            </td>
            <td>
              <tt>is_swappable&lt;T,U&gt;::value</tt> is true  and
              <tt>noexcept(swap(declval&lt;T&&gt;(), declval&lt;U&&gt;()))</tt> is true. Note
              that the latter expression is only valid if the former is true, but simply anding
              these expressions together will not work correctly.
            </td>
            <td>
              The set of swaps considered for resolution must include <tt>std::swap</tt> as
              well as swap overloads available via argument dependent lookup.
            </td>
          </tr>
        </table>
      </center>
    </p>

    <a name="impl"><h2>VII. Implementation</h2></a>
    <p>
      The following is one possible implementation of the above specification, derived from <a href="#biblio.github-acm-swap-traits">[2]</a>:
      <blockquote><tt><pre>
namespace std {
  namespace adl_swap_ns {
    using std::swap;

    template&lt;typename T, typename U&gt;
    class is_swappable_test {

      struct swap_not_found_type {};

      template&lt;typename V1, typename V2&gt;
      static auto test(V1&amp; v1, V2&amp; v2) -&gt; decltype(swap(v1, v2));

      template&lt;typename V1, typename V2&gt;
      static auto test(...) -&gt; swap_not_found_type;

      using test_type = decltype(test&lt;T, U&gt;(std::declval&lt;T&amp;&gt;(), std::declval&lt;U&amp;&gt;()));

    public:
      static constexpr bool value = !std::is_same&lt;test_type, swap_not_found_type&gt;::value;
    };

    template&lt;bool, typename T, typename U&gt;
    struct is_nothrow_swappable_test :
      std::conditional&lt;noexcept(swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;U&amp;&gt;())),
                       std::true_type, std::false_type&gt;::type {};

    template&lt;typename T, typename U&gt;
    struct is_nothrow_swappable_test&lt;false, T, U&gt; :
      std::false_type {};

  }

  template&lt;typename T, typename U = T&gt;
  struct is_swappable :
    std::conditional&lt;adl_swap_ns::is_swappable_test&lt;T, U&gt;::value,
                     std::true_type, std::false_type&gt;::type {};

  template&lt;typename T, typename U = T&gt;
  struct is_nothrow_swappable :
    adl_swap_ns::is_nothrow_swappable_test&lt;is_swappable&lt;T, U&gt;::value, T, U&gt; {};
}
      </pre></tt></blockquote>
    </p>

    <a name="thanks"><h2>VIII. Acknowledgements</h2></a>
    <p>
      <ul>
        <li> Howard Hinnant, for encouraging me to work on this proposal. <a href="#biblio.so-acm-why-no-swap-traits">[4]</a>
      </ul>
    </p>

    <a name="biblio"><h2>IX. References</h2></a>

    <ul>
      <li>
        <a name="biblio.so-adl-noexcept" href=http://stackoverflow.com/questions/7635939/how-do-i-write-an-adl-enabled-noexcept-specification>[1] Stackoverflow post on writing an ADL enabled noexcept specification</a>
      </li>

      <li>
        <a name="biblio.github-acm-swap-traits" href=https://github.com/acmorrow/error_or/blob/master/detail/is_nothrow_swappable.hpp>[2] Implementation of swap traits in a github project</a>
      </li>

      <li>
        <a name="biblio.libcxx-swap-trats" href=http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/type_traits?view=markup>[3] See __is_swappable and __is_nothrow_swappable in libc++ <tt>&lt;type_traits&gt;</tt>.</a>
      </li>

      <li>
        <a name="biblio.so-acm-why-no-swap-traits" href=http://stackoverflow.com/questions/14483105/why-are-is-swappable-and-is-nothrow-swappable-not-included-in-c11>[4] Stackoverflow post requesting information on why C++11 does not offer swappability traits</a>
      </li>

    </ul>
  </body>
</html>
